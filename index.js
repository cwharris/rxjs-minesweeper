// Generated by CoffeeScript 1.4.0
(function() {
  var makeMinefield, makeMinefieldUnit, makeMinefieldUnitView, makeMinefieldView;

  (function() {
    var longPressDelay, tapDelay, tapRelease;
    tapDelay = 200;
    longPressDelay = 200;
    $.fn.tapReleaseAsObservable = function() {
      return Rx.Observable.merge($(this).onAsObservable('mouseup'), $(this).onAsObservable('touchend'));
    };
    tapRelease = $(document).tapReleaseAsObservable();
    $.fn.tapAsObservable = function() {
      return Rx.Observable.merge($(this).onAsObservable('mousedown'), $(this).onAsObservable('touchstart')).doAction(function(e) {
        return e.preventDefault();
      }).selectMany(function(e) {
        return tapRelease.select(function() {
          return e;
        }).take(1).takeUntil(Rx.Observable.interval(tapDelay).take(1));
      });
    };
    return $.fn.longPressAsObservable = function() {
      return Rx.Observable.merge($(this).onAsObservable('mousedown'), $(this).onAsObservable('touchstart')).selectMany(function(e) {
        return Rx.Observable.returnValue(e).delay(longPressDelay).takeUntil(tapRelease);
      });
    };
  })();

  makeMinefieldUnit = function() {
    var friends, unit;
    unit = {};
    friends = [];
    unit.isBomb = new Rx.BehaviorSubject(false);
    unit.isCovered = new Rx.BehaviorSubject(true);
    unit.numBombs = new Rx.BehaviorSubject(0);
    unit.flag = new Rx.BehaviorSubject('none');
    unit.addFriend = function(friend) {
      friends.push(friend);
      return friend.isBomb.skipWhile(function(x) {
        return !x;
      }).subscribe(function(isBomb) {
        return unit.numBombs.onNext(unit.numBombs.value + (isBomb ? 1 : -1));
      });
    };
    unit.getFriends = function() {
      return friends;
    };
    unit.nextFlag = function() {
      switch (unit.flag.value) {
        case 'none':
          unit.flag.onNext('certain');
          break;
        case 'certain':
          unit.flag.onNext('uncertain');
          break;
        default:
          return unit.flag.onNext('none');
      }
    };
    return unit;
  };

  makeMinefield = function(width, height, numMinesRequested) {
    var friendUnit, i, minefield, reveals, unit, x, xOffset, y, yOffset, _fn, _i, _j, _k, _l, _m, _ref;
    minefield = {
      width: width,
      height: height,
      numBombs: new Rx.BehaviorSubject(numMinesRequested),
      numFlags: new Rx.BehaviorSubject(0),
      units: [],
      solved: new Rx.Subject
    };
    reveals = new Rx.Subject;
    minefield.getUnit = function(x, y) {
      if (x < 0 || y < 0 || x >= minefield.width || y > minefield.height) {
        return void 0;
      }
      return minefield.units[y * minefield.width + x];
    };
    minefield.populateBombsWithFirstReveal = function(unit, numMinesRequested) {
      var friend, i, index, tempUnits, _i, _j, _len, _ref, _results;
      tempUnits = minefield.units.slice(0);
      index = tempUnits.indexOf(unit);
      tempUnits.splice(index, 1);
      _ref = unit.getFriends();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        friend = _ref[_i];
        index = tempUnits.indexOf(friend);
        tempUnits.splice(index, 1);
      }
      _results = [];
      for (i = _j = 0; 0 <= numMinesRequested ? _j < numMinesRequested : _j > numMinesRequested; i = 0 <= numMinesRequested ? ++_j : --_j) {
        if (tempUnits.length <= 0) {
          minefield.numBombs.onNext(i);
          break;
        }
        index = Math.floor(Math.random() * tempUnits.length);
        unit = tempUnits[index];
        tempUnits.splice(index, 1);
        _results.push(unit.isBomb.onNext(true));
      }
      return _results;
    };
    _fn = function() {
      var unit;
      unit = minefield.units[i] = makeMinefieldUnit();
      reveals = reveals.merge(unit.isCovered.where(function(isCovered) {
        return !isCovered;
      }).select(function() {
        return unit;
      }));
      return unit.flag.select(function(x) {
        if (x === 'certain') {
          return 1;
        } else {
          return -1;
        }
      }).skipWhile(function(x) {
        return x < 0;
      }).distinctUntilChanged().select(function(x) {
        return minefield.numFlags.value + x;
      }).subscribe(minefield.numFlags);
    };
    for (i = _i = 0, _ref = width * height; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      _fn();
    }
    for (x = _j = 0; 0 <= width ? _j < width : _j > width; x = 0 <= width ? ++_j : --_j) {
      for (y = _k = 0; 0 <= height ? _k < height : _k > height; y = 0 <= height ? ++_k : --_k) {
        unit = minefield.getUnit(x, y);
        for (xOffset = _l = -1; _l <= 1; xOffset = ++_l) {
          for (yOffset = _m = -1; _m <= 1; yOffset = ++_m) {
            if (xOffset === 0 && yOffset === 0) {
              continue;
            }
            friendUnit = minefield.getUnit(x - xOffset, y - yOffset);
            if (friendUnit !== void 0) {
              unit.addFriend(friendUnit);
            }
          }
        }
      }
    }
    reveals.take(1).subscribe(function(unit) {
      return minefield.populateBombsWithFirstReveal(unit, numMinesRequested);
    });
    minefield.solved = reveals.combineLatest(minefield.numBombs, function(_, x) {
      return x;
    }).where(function(numBombs) {
      var coveredUnits;
      coveredUnits = _.filter(minefield.units, function(unit) {
        return unit.isCovered.value;
      });
      return numBombs === coveredUnits.length;
    }).take(1);
    minefield.failed = reveals.where(function(x) {
      return x.isBomb.value;
    }).take(1);
    reveals.where(function(unit) {
      return unit.numBombs.value === 0 && !unit.isBomb.value;
    }).delay(25).subscribe(function(unit) {
      var friend, _len, _n, _ref1, _results;
      _ref1 = unit.getFriends();
      _results = [];
      for (_n = 0, _len = _ref1.length; _n < _len; _n++) {
        friend = _ref1[_n];
        if (friend.isCovered.value) {
          _results.push(friend.isCovered.onNext(false));
        }
      }
      return _results;
    });
    return minefield;
  };

  makeMinefieldUnitView = function(unit, x, y, size, spacing) {
    var comb, dom, domBombCount, inputDisposable;
    dom = $('<div class="minefield-unit">');
    domBombCount = $('<p class="bomb-count">').appendTo(dom);
    dom.tapAsObservable().where(function() {
      return !unit.isCovered.value;
    }).select(function() {
      return _.filter(unit.getFriends(), function(friend) {
        return friend.flag.value !== 'none' && friend.isCovered.value;
      });
    }).where(function(x) {
      return x.length === unit.numBombs.value;
    }).take(1).select(function() {
      return _.filter(unit.getFriends(), function(friend) {
        return friend.flag.value === 'none';
      });
    }).subscribe(function(friends) {
      return _.each(friends, function(friend) {
        return friend.isCovered.onNext(false);
      });
    });
    inputDisposable = new Rx.CompositeDisposable;
    inputDisposable.add(dom.tapAsObservable().where(function() {
      return unit.flag.value === 'none';
    }).take(1).subscribe(function() {
      console.log('tap');
      return unit.isCovered.onNext(false);
    }));
    inputDisposable.add(dom.longPressAsObservable().subscribe(function() {
      console.log('long press');
      return unit.nextFlag();
    }));
    comb = size.combineLatest(spacing, function(size, spacing) {
      return {
        size: size,
        spacing: spacing
      };
    });
    comb.subscribe(function(comb) {
      return dom.css({
        position: 'absolute',
        left: x * (comb.size + comb.spacing),
        top: y * (comb.size + comb.spacing),
        width: comb.size,
        height: comb.size
      });
    });
    unit.isBomb.subscribe(function(isBomb) {
      return dom.toggleClass('bomb', isBomb);
    });
    unit.isCovered.where(function(x) {
      return !x;
    }).take(1).subscribe(function() {
      console.log('dispose inputs');
      return inputDisposable.dispose();
    });
    unit.isCovered.subscribe(function(isCovered) {
      return dom.toggleClass('covered', isCovered);
    });
    unit.numBombs.subscribe(function(numBombs) {
      dom.toggleClass('near-bomb', numBombs > 0);
      return domBombCount.html(numBombs);
    });
    unit.flag.subscribe(function(flag) {
      dom.toggleClass('flag-none', flag === 'none');
      dom.toggleClass('flag-certain', flag === 'certain');
      return dom.toggleClass('flag-uncertain', flag === 'uncertain');
    });
    return dom;
  };

  makeMinefieldView = function(minefield, mineSize, mineSpacing) {
    var controller, dom, i, unit, x, y, _i, _len, _ref;
    dom = $('<div class="minefield">');
    controller = {};
    _ref = minefield.units;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      unit = _ref[i];
      x = i % minefield.width;
      y = Math.floor(i / minefield.width);
      dom.append(makeMinefieldUnitView(unit, x, y, mineSize, mineSpacing));
    }
    return dom;
  };

  $(function() {
    var domBombCount, height, holder, minefield, minefieldView, numRemaining, size, spacing, width;
    width = 16;
    height = 16;
    size = new Rx.BehaviorSubject(40);
    spacing = new Rx.BehaviorSubject(3);
    minefield = makeMinefield(width, height, 30);
    minefieldView = makeMinefieldView(minefield, size, spacing);
    $('body').append(minefieldView);
    size.combineLatest(spacing, function(size, spacing) {
      return {
        size: size,
        spacing: spacing
      };
    }).subscribe(function(x) {
      var totalHeight, totalWidth;
      totalWidth = (x.size * width) + (x.spacing * width - 1);
      totalHeight = (x.size * height) + (x.spacing * height - 1);
      console.log(x.size, x.spacing, totalWidth, totalHeight);
      return minefieldView.css({
        width: totalWidth,
        height: totalHeight
      });
    });
    holder = $('<div>').css({
      'position': 'fixed'
    }).appendTo('body');
    holder.append(domBombCount = $('<div class="bomb-count">'));
    numRemaining = minefield.numBombs.combineLatest(minefield.numFlags, function(numBombs, numFlags) {
      return numBombs - numFlags;
    });
    numRemaining.subscribe(function(numRemaining) {
      return domBombCount.html(numRemaining);
    });
    minefield.failed.takeUntil(minefield.solved).subscribe(function() {
      var bombs;
      alert('FAILED');
      bombs = _.filter(minefield.units, function(unit) {
        return unit.isBomb.value;
      });
      return Rx.Observable.interval(10).take(bombs.length).select(function(i) {
        return bombs[i];
      }).subscribe(function(unit) {
        return unit.isCovered.onNext(false);
      });
    });
    return minefield.solved.takeUntil(minefield.failed).subscribe(function() {
      var bombs;
      alert('SOLVED');
      bombs = _.filter(minefield.units, function(unit) {
        return unit.isBomb.value;
      });
      return Rx.Observable.interval(10).take(bombs.length).select(function(i) {
        return bombs[i];
      }).subscribe(function() {
        return bomb.isCovered.onNext(false);
      });
    });
  });

}).call(this);
